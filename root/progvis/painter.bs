use ui;
use layout;
use graphics;
use core:geometry;
use core:io;
use progvis:program;
use progvis:data;
use progvis:view;

class MainPainter extends Painter {
	// The workspace we want to draw.
	private view:Workspace workspace;

	// World of the program's state. Also has a reference to the actual program.
	private World? world;

	// Memory model to check for.
	private MemoryChecks memChecks;

	// Problem panel, if any.
	private ProblemPanel? panel;

	// Lock for traversals.
	private core:sync:Lock traverseLock;

	// Left mouse button pressed?
	private Bool mouseDown;

	// Current drawable object in focus. Only useful when 'mousedown' is pressed.
	private view:Drawable? mouseFocus;

	// Location mouse was pressed at.
	private Point mouseOffset;

	// Offset for the workspace.
	private Point offset;

	// Scale factor for the workspace. Applied last, meaning that "offset" and "mouseOffset" are also scaled.
	private Float scale;

	// Behavior to use in the painter.
	private Behavior? behavior;

	init() {
		init() { scale = 1.0; }
		bgColor = Color(0.8, 0.8, 0.8);
	}

	// Set the memory model.
	void checkMemory(MemoryChecks mode) {
		memChecks = mode;
		if (world) {
			world.trackMemory = mode;
			// Might deadlock otherwise (if we get an error message).
			spawn update();
		}
	}

	// Set zoom. Also pans to the center to make sure nothing gets hidden too badly.
	void setZoom(Float zoom) {
		if (scale != zoom) {
			offset = Point();
			scale = zoom;
		}
	}

	// Do we have an open "program" instance?
	Bool hasProgram() {
		world.any;
	}

	// Update the behavior without re-loading a program.
	void updateBehavior(Behavior b) {
		behavior = b;
		panel = b.panel;
		workspace.enableStep = b.allowStep;
	}

	// Open a program.
	void open(Url[] files, Behavior b) {
		var loaded = Program:load(files);

		// Terminate the previous program, if any. We do that here in case the load failed.
		cleanup();

		var w = World(loaded);
		world = w;
		updateBehavior(b);
		w.trackDeadlock = true;
		w.trackMemory = memChecks;
		loaded.onChange = &this.update();
		loaded.onError = &this.onProgramError;
		loaded.onAdvance = &this.onProgramAdvance;
		update();
		loaded.spawn(loaded.main);
	}

	// Try to find the loaded source code for the program.
	Str? sourceFor(Url url) {
		if (world)
			if (text = world.program.source(url))
				return text.text;
		null;
	}

	// Apply an action. These are the same that we produce to the Behavior.
	void applyAction(Str action) {
		unless (world)
			return;

		Bool barrier = false;
		if (action.endsWith("*")) {
			barrier = true;
			action = action.cut(action.begin, action.findLast("*".begin.v));
		}

		if (action == "s") {
			// Spawn new thread.
			spawnThread();
		} else if (action.isNat) {
			// Step a thread.
			Nat thread = action.toNat;
			for (v in world.program.threads) {
				if (v.threadId == thread) {
					if (barrier & v.barriersAvailable)
						v.resumeBarrier();
					else
						v.resume();
				}
			}
		}
	}

	private void onProgramError(ThreadError error) {
		unless (behavior)
			return;

		stopThreads();
		behavior.onProgramError(error);
	}

	private void onProgramAdvance(Nat thread, Bool barrier) {
		unless (behavior)
			return;

		var action = thread.toS;
		if (barrier)
			action += "*";

		behavior.onUserAction(action);
	}

	// Clean up the running program (i.e. make sure all threads are terminated).
	void cleanup() {
		// Don't call any behavior during termination.
		behavior = null;
		panel = null;

		if (world) {
			// This calls terminate if necessary.
			world.clear();
		}

		workspace.clear();
		offset = Point();
		repaint();
	}

	// Restart the program.
	void restart() {
		if (world) {
			// Don't call behavior during restart.
			var tmp = behavior;
			behavior = null;

			world.clear();
			workspace.clear();

			behavior = tmp;
			if (behavior)
				behavior.onRestart();
			world.program.spawn(world.program.main);
		}
	}

	// Spawn another thread.
	void spawnThread() {
		if (world) {
			world.program.spawn(world.program.main);
			if (behavior)
				behavior.onUserAction("s");
		}
	}

	// Stop all running threads.
	void stopThreads() {
		if (world) {
			for (k, v in world.program.threads) {
				v.pause();
			}
		}
	}

	// Start all threads with the specified speed
	void resumeThreads(Duration speed) {
		if (world) {
			for (k, v in world.program.threads) {
				v.resume(speed);
			}
		}
	}

	// Render everything.
	Bool render(Size me, Graphics g) : override {
		g.transform(translate(-offset) * scale(scale));

		Rect viewport(offset, me / scale);
		workspace.render(viewport, g);

		if (panel)
			panel.render(viewport, g);

		false;
	}

	// Update the visualization of the data.
	void update() {
		ProgramError? error;

		if (world) {
			core:sync:Lock:Guard z(traverseLock);

			// Don't update now if at least one thread is running some code. If that is the case, we
			// will get an intermediate view of that thread, and possibly report sporadic errors. We
			// also know that the thread that is running will eventually pause again, and we will
			// try to update later. As such, it is safe to just abort if we find that a thread is
			// running, we don't actively need to try again.
			if (!world.program.threadsPaused) {
				return;
			}

			error = world.update();

			if (o = world.program.getOutput())
				workspace.outputText(o);

			workspace.update(world);
		}

		repaint();

		if (error) {
			stopThreads();
			if (behavior) {
				behavior.onProgramError(error);
			}
		}
	}

	// Called when the mouse is moved.
	void mouseMoved(Point pt) {
		if (!mouseDown)
			return;

		pt /= scale;
		pt += offset;

		if (mouseFocus) {
			// Call the drawable.
			if (mouseFocus.mouseMoved(pt, mouseOffset))
				repaint();
		} else {
			// Update our transform.
			offset -= pt - mouseOffset;
			repaint();
		}
	}

	// Called when a mouse button is clicked.
	void mouseClicked(Point pt, Bool down, MouseButton button) {
		pt /= scale;
		pt += offset;

		if (button == MouseButton:left) {
			if (down) {
				if (panel) {
					if (panel.mouseClicked(pt))
						return;
				}

				mouseDown = true;
				mouseOffset = pt;
				mouseFocus = workspace.findAtActivate(pt);

				if (mouseFocus) {
					mouseFocus.mouseClicked(pt, down);
				}

				repaint();
			} else {
				mouseOffset = pt;
				mouseLeave();
			}
		}
	}

	// Called when the mouse leaves the window.
	void mouseLeave() {
		if (mouseFocus) {
			// Tell it we released the cursor. We might want to differentiate between the two cases later on...
			if (mouseFocus.mouseClicked(mouseOffset, false))
				repaint();
		}

		mouseDown = false;
		mouseFocus = null;
	}
}
