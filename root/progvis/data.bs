use ui;
use graphics;
use core:geometry;
use lang:bs:macro;


/**
 * A data structure instantiated somewhere. Managed by a Workspace.
 */
class Data extends Drawable {
	// Draw this data item at its current location.
	void draw(Graphics g, Bool active) : abstract {
		Rect r = rect;
		g.fill(r, dataBg);
		g.draw(r, dataFg);
	}

	void drawLinks(Graphics g, Bool active) : override {}

	// Update the contents of the visualization from the actual data.
	void update(Workspace work, unsafe:RawPtr object, Nat offset) : abstract;

	// Find a particular offset inside this data.
	DataOffset findOffset(Nat offset) { DataOffset(this); }
}

/**
 * Representation of an offset inside some data visualization.
 */
value DataOffset {
	// Inside this element.
	Data data;

	// Y-offset in pixels.
	Float offset;

	// Create.
	init(Data data) {
		init { data = data; offset = 0; }
	}
	init(Data data, Float offset) {
		init { data = data; offset = offset; }
	}
}


/**
 * Data element with a caption.
 */
class DataWithCaption extends Data {
	init(Data wrap, Str caption) {
		Text c(caption, captionFont);

		init() {
			wrap = wrap;
			caption = c;
			captionSz = c.size + compositeBorder*2;
		}
	}

	Size size() : override {
		Size sz = wrap.size();
		sz.w = max(sz.w, captionSz.w);
		sz.h += captionSz.h;
		sz;
	}

	void draw(Graphics g, Bool active) : override {
		Size cSz = captionSz;
		Size wSz = wrap.size;
		cSz.w = max(cSz.w, wSz.w);
		g.fill(Rect(pos, cSz), if (active) { captionActiveBg; } else { captionBg; });
		g.draw(caption, captionFg, pos + compositeBorder);
		g.draw(Rect(pos, cSz), captionFg);

		wrap.size(Size(cSz.w, wSz.h));

		wrap.pos = pos + Size(0, captionSz.h);
		wrap.draw(g, active);
	}

	void drawLinks(Graphics g, Bool active) : override {
		wrap.drawLinks(g, active);
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		wrap.update(work, object, offset);
	}

	DataOffset findOffset(Nat offset) : override {
		wrap.findOffset(offset);
	}

	Bool remove() : override {
		wrap.remove();
	}

	// Return the sub-drawable if the click is there.
	Drawable findAt(Point pt) : override {
		if (wrap.rect.contains(pt))
			wrap.findAt(pt);
		else
			this;
	}

	// Called when the mouse is pressed inside this drawable.
	Bool mouseClicked(Point pt, Bool down) {
		if (down) {
			mouseOrigin = pt - pos;
		} else {
			mouseOrigin = null;
		}
		false;
	}

	// Called when the mouse is moved inside this drawable. "origin" is the location (in world space) where it was pressed.
	Bool mouseMoved(Point pt, Point origin) {
		if (mouseOrigin) {
			pos = pt - mouseOrigin;
			return true;
		}

		false;
	}

	// The drawable we're wrapping.
	Data wrap;

	// Caption text.
	private Text caption;

	// Size of the caption area.
	private Size captionSz;

	// Origin of mouse when pressed.
	private Point? mouseOrigin;
}

/**
 * Unknown data element.
 */
class UnknownData extends Data {
	private Text text;

	init() {
		init() {
			text = Text("?", dataFont);
		}

		size = text.size + dataBorder*2;
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);
		g.draw(text, dataFg, pos + dataBorder);
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {}
}


/**
 * A primitive datatype, such as an integer. Represented as text.
 */
class Primitive extends Data {
	// The text to draw.
	private Text text;

	// Type of the data we're displaying.
	core:lang:Type type;

	// Size of the data.
	Nat typeSize;

	init(core:lang:Type type, Str initial) {
		init() {
			text = Text(initial, dataFont);
			type = type;
			typeSize = core:lang:Value(type).size.current;
		}
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);
		g.draw(text, dataFg, pos + dataBorder);
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		if (s = convertPrimitive(type, object, offset)) {
			text = Text(s, dataFont);
			invalidateSize();
		}
	}

	Size computeSize() {
		text.size + dataBorder*2;
	}

	DataOffset findOffset(Nat offset) : override {
		Float o = offset.int.float / typeSize.int.float;
		DataOffset(this, o * size.h);
	}
}

// Arrow for all pointers.
package Path ptrArrow on Render = {
	Path p;
	p.start(Point(0, 0));
	p.line(Point(-6, -4));
	p.line(Point(-6, 4));
	p.close();
	p;
};

/**
 * A pointer type, referring to some other data.
 */
class Pointer extends Data {
	// Object we're pointing to.
	protected Data? to;

	// Y-offset inside 'to', if present.
	protected Float offset;

	// Our path, re-used for efficiency.
	private Path line;

	init() {
		init() {}

		size = Text("????", dataFont).size + dataBorder*2;
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);
		if (to) {
		} else {
			// Null.
			Rect r = rect;
			g.line(rect.p0, rect.p1, activeLink);
		}
	}

	void drawLinks(Graphics g, Bool active) : override {
		if (to) {
			Point target = to.pos;
			target.y += offset;

			Brush color = if (active) { activeLink; } else { inactiveLink; };
			Rect r = rect;
			// g.line(r.center, to.pos, color);
			Float dy = abs(r.center.y - target.y);
			Float shift = max(0.2*dy, 40);
			line.clear();
			line.start(r.center);
			line.bezier(target - Point(shift, 0), target);
			g.draw(line, color);

			g.push();
			g.transform(translate(target));
			g.fill(ptrArrow, color);
			g.pop();
		}
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		var ptr = object.readPtr(offset);
		if (ptr.any) {
			var off = work.traverse(ptr).findOffset(0);
			this.to = off.data;
			this.offset = off.offset;
		} else {
			to = null;
		}
	}

	DataOffset findOffset(Nat offset) : override {
		Float o = offset.int.float / core:asm:sPtr.current.int.float;
		DataOffset(this, o * size.h);
	}
}

/**
 * A pointer on the stack. Examines the pointer passed directly to the object rather than
 * dereferencing it once first.
 */
class StackPointer extends Pointer {
	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		if (object.any) {
			var off = work.traverse(object).findOffset(0);
			this.to = off.data;
			this.offset = off.offset;
		} else {
			to = null;
		}
	}
}

/**
 * A composite type, consisting of one or more variables of other types.
 */
class Composite extends Data {
	init() {
		init() {}
	}

	void add(Str name, Nat offset, Data data, Bool divider) {
		if (content.empty)
			divider = false;

		content << Var(name, data, offset, divider);
		invalidateSize();
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);
		Float width = rect.size.w;
		Point at = pos + compositeBorder;

		for (v in content) {
			var nameSz = v.text.size;
			var dataSz = v.value.size;

			if (v.line) {
				g.line(Point(pos.x, at.y), Point(pos.x + width, at.y), dataFg);
				at.y += dataBorder.h;
			}

			// Align the text a bit nicer on the y-axis, to line up the baselines...
			g.draw(v.text, dataFg, at + Point(0, dataBorder.h));

			v.value.pos = at + Point(namesWidth + dataWidth - dataSz.w, 0);
			v.value.draw(g, false);

			at.y += max(nameSz.h, dataSz.h) + dataBorder.h;
		}
	}

	void drawLinks(Graphics g, Bool active) : override {
		for (v in content) {
			v.value.drawLinks(g, active);
		}
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		for (v in content) {
			v.value.update(work, object, offset + v.offset);
		}

		invalidateSize();
	}

	DataOffset findOffset(Nat offset) : override {
		if (offset == 0)
			return DataOffset(this);
		if (content.empty)
			return DataOffset(this);

		for (Nat i = 1; i < content.count; i++) {
			if (content[i].offset > offset) {
				var found = content[i - 1];
				return found.value.findOffset(offset - found.offset);
			}
		}

		var found = content.last;
		return found.value.findOffset(offset - found.offset);
	}

private:
	class Var on Render {
		Str name;
		Text text;
		Data value;
		Nat offset;
		// Line before?
		Bool line;

		init(Str name, Data value, Nat offset, Bool divider) {
			init() {
				name = name;
				text = Text(name, dataFont);
				value = value;
				offset = offset;
				line = divider;
			}
		}
	}

	Var[] content;
	Float namesWidth;
	Float dataWidth;
	Float height;

	Size computeSize() : override {
		// TODO: It would probably be nice to recurse into
		// the values that are themselves variables and render them
		// more compactly.
		namesWidth = 0;
		dataWidth = 0;
		height = 0;
		for (v in content) {
			var nameSz = v.text.size;
			var dataSz = v.value.size;

			namesWidth = max(namesWidth, nameSz.w + dataBorder.w);
			dataWidth = max(dataWidth, dataSz.w);
			height += max(nameSz.h, dataSz.h) + dataBorder.h;

			if (v.line)
				height += dataBorder.h;
		}

		height -= dataBorder.h;
		Size(namesWidth + dataWidth, height) + compositeBorder*2;
	}
}

/**
 * A class describing an array.
 */
class ArrayData extends Data {
	init(core:lang:Type type) {
		init() {
			typeInfo = TypeInfo(type, core:lang:Value(type).isValue, false);
		}
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);
		Float width = rect.size.w;
		Point at = pos + compositeBorder;

		for (v in content) {
			var nameSz = v.text.size;
			var dataSz = v.value.size;

			// Align the text a bit nicer on the y-axis, to line up the baselines...
			g.draw(v.text, dataFg, at + Point(0, dataBorder.h));

			v.value.pos = at + Point(namesWidth + dataWidth - dataSz.w, 0);
			v.value.draw(g, false);

			at.y += max(nameSz.h, dataSz.h) + dataBorder.h;
		}
	}

	void drawLinks(Graphics g, Bool active) : override {
		for (v in content) {
			v.value.drawLinks(g, active);
		}
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		// TODO: Extract the actual offset!
		Nat dataOffset = object.readSize - core:asm:sPtr.current;
		unsafe:RawPtr data = object.readPtr(offset + dataOffset);
		if (data.empty) {
			// TODO: Write "empty" or something like that.
			return;
		}

		Nat stride = data.readSize;
		Nat count = data.readFilled;

		// Update the elements that are already present.
		for (Nat i = 0; i < content.count; i++) {
			content[i].value.update(work, data, i*stride);
		}

		// Create new elements.
		for (Nat i = content.count; i < count; i++) {
			Var v(i, work.createData(typeInfo, data, i*stride));
			content << v;
			v.value.update(work, data, i*stride);
		}

		// Remove any extra.
		while (content.count > count) {
			content.pop();
		}

		invalidateSize();
	}

private:
	TypeInfo typeInfo;

	class Var on Render {
		Text text;
		Data value;

		init(Nat id, Data value) {
			init() {
				text = Text(id.toS + ":", dataFont);
				value = value;
			}
		}
	}

	Var[] content;
	Float namesWidth;
	Float dataWidth;
	Float height;

	Size computeSize() : override {
		namesWidth = 0;
		dataWidth = 0;
		height = 0;
		for (v in content) {
			var nameSz = v.text.size;
			var dataSz = v.value.size;

			namesWidth = max(namesWidth, nameSz.w + dataBorder.w);
			dataWidth = max(dataWidth, dataSz.w);
			height += max(nameSz.h, dataSz.h) + dataBorder.h;
		}

		height -= dataBorder.h;
		Size(namesWidth + dataWidth, height) + compositeBorder*2;
	}
}
