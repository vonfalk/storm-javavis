// This is the syntax for the Basic Storm language.

use core.lang;

delimiter = SDelimiter;

// Delimiter, may contain comments.
void SDelimiter();
SDelimiter : "[ \n\r\t]*" - (SCommentStart #comment - SDelimiter)?;

// Start of comments.
void SCommentStart();
SCommentStart : "//[^\n\r]*[\n\r]";
SCommentStart : "/" - "\*" - [SInComment]@;

// Inside a multi-line comment. Consumes the ending */
void SInComment();
// End of the comment.
SInComment : "\*+/";
// Start of a nested comment.
SInComment : "/\*+" - SInComment - SInComment;
// Everything except * and / are fine.
SInComment : "[^\*/]*" - SInComment;
// Match any number of * followed by anything other than a /
SInComment : "\*+[^\*/]" - SInComment;
// Match any number of /
SInComment : "/+" - SInComment;


// Comments for documentation. Either a block of single line comments not separated by more than a
// single blank line or a single multi-line comment. Returns the start position of the comment
// so that it is possible to find it again later.
SrcPos SDocComment() #comment;
SDocComment => pos : ("//[^\n\r]*\r?\n[ \t]*")+;
SDocComment => pos : "/" - "\*" - [SInComment]@ - "[ \t]*\n[ \t]*";

SrcPos SFindDoc();
SFindDoc[5] => p : "[ \t\n\r]*" - SDocComment p;
SFindDoc[0] => p : SFindDoc - "[ \t\n\r]*" - SDocComment p;

// A name in Storm. This should probably be extended to handle more of unicode.
SStr SName();
SName => s : "[A-Za-z_][A-Za-z0-9_]*"@ s;

// Part in a type name.
NamePart STypePart();
STypePart => SimplePart(name) : SName name;
STypePart => SimplePart(name) : SName name, "<", ">";
STypePart => RecPart(name) : SName name, "<", SType -> add, (",", SType -> add, )* ">";

// Type.
SrcName SType();
SType => SrcName(pos) : STypePart -> add #typeName, (":", STypePart -> add #typeName, )*;

// Array type.
SType => arrayType(t) : SType t, "\[\]";

// Map type.
SType[-10] => mapType(k, v) : SType k, "->", SType v;

// Maybe type.
SType[10] => maybeType(t) : SType t, "\?" #typeName;

// Function pointers.
SType => fnPtrType(result, params) : "fn" #keyword, SFnTypes params, "->", SType result;
SType => fnPtrType(params) : "fn" #keyword, SFnTypes params, "->";

// Function name. Very similar to 'SType'.
SrcName SFnName();
SFnName => SrcName(pos) : (STypePart -> add #typeName, ":", )* STypePart -> add #varName;

// Package. Separate entry so to not allow package names like: a:b[] or a:b->c:d.
SrcName SPackage();
SPackage => SrcName(pos) : STypePart -> add #typeName - (, ":", STypePart -> add #typeName)*;

// List of types.
Array<SrcName> STypes();
STypes => Array<SrcName>() : "";
STypes => Array<SrcName>() : SType -> push - (, ",", SType -> push)*;

Array<SrcName> SFnTypes();
SFnTypes => Array<SrcName>() : "";
SFnTypes => t : "(", STypes t, ")";


// Strings and their content:
// Note: Storm uses interpolated strings now, so this is not actually used by Storm. It is, however, provided
// here for other languages that wish to accept 'plain' strings.
void SStrContent();
SStrContent : "[^\"\\\n]*"; // All except end of string and backslash.
SStrContent : SStrContent - "\\." - SStrContent; // Gobble escape sequences (we could translate them here...)

Str SString();
SString => s : "\"" #string - (SStrContent #string) s - "\"" #string;

// Parameter list (possibly empty).
Array<NameParam> SFormals();
SFormals => Array<NameParam>() : "";
SFormals => Array<NameParam>() : SFormal -> push - (, ",", SFormal -> push)*;

NameParam SFormal();
SFormal => NameParam(type, name) : SType type, SName name #varName;

// Function.
FunctionDecl SFunction(Scope env);
SFunction[0] => FunctionDecl(env, result, name, params, body) :
    SType result, SFnDeclName name #fnName, "(", SFormals params, ")", "{" [, SFunctionBody@ body, ]+ "}";
SFunction[5] => assignDecl(env, name, params, body) :
    "assign" #keyword, SFnDeclName name #fnName, "(", SFormals params, ")", "{" [, SFunctionBody@ body, ]+ "}";
SFunction[0] => FunctionDecl(env, result, name, params, thread, body) :
    SType result, SFnDeclName name #fnName, "(", SFormals params, ")", "on" #keyword, SType thread, "{" [, SFunctionBody@ body, ]+ "}";
SFunction[5] => assignDecl(env, name, params, thread, body) :
    "assign" #keyword, SFnDeclName name #fnName, "(", SFormals params, ")", "on" #keyword, SType thread, "{" [, SFunctionBody@ body, ]+ "}";

// Function names. Slightly wider than a regular Name, since we allow operators here as well.
SStr SFnDeclName();
SFnDeclName => name : SName name;
SFnDeclName => name : (SOperator)@ name;
SFnDeclName => name : (SPreOp)@ name;
SFnDeclName => name : (SPrePostOp - "\*")@ name;
SFnDeclName => name : ("\*" - SPrePostOp)@ name;


// Class/value.
Class SClass(Scope env);
SClass => createClass(pos, env, name, body) : "class" #keyword, SName name #typeName, "{" - [SClassBody@ body, ]+ "}";
SClass => createValue(pos, env, name, body) : "value" #keyword, SName name #typeName, "{" - [SClassBody@ body, ]+ "}";
SClass => extendClass(pos, env, name, base, body) : "class" #keyword , SName name #typeName, "extends" #keyword, SType base, "{" - [SClassBody@ body, ]+ "}";
SClass => extendValue(pos, env, name, base, body) : "value" #keyword, SName name #typeName, "extends" #keyword, SType base, "{" - [SClassBody@ body, ]+ "}";
SClass => threadClass(pos, env, name, thread, body) : "class" #keyword, SName name #typeName, "on" #keyword, SType thread, "{" - [SClassBody@ body, ]+ "}";
SClass => threadClass(pos, env, name, body) : "class" #keyword, SName name #typeName, "on" #keyword, "\?", "{" - [SClassBody@ body, ]+ "}";

// Named thread declaration.
NamedThread SNamedThread();
SNamedThread => NamedThread(name) : "thread" #keyword, SName name, ";";

// Possible root blocks in a file.
TObject SFileItem(Scope env);
SFileItem => item : SPlainFileItem(env) item;
SFileItem => apply(pos, item, access) : SFreeAccess access - " ", SPlainFileItem(env) item;
SFileItem => access : SDelimiter - [SFreeAccess access - ":"]-;

TObject SPlainFileItem(Scope env);
SPlainFileItem => f : SFunction(env) f;
SPlainFileItem => c : SClass(env) c;
SPlainFileItem => t : SNamedThread t;

TObject SDocFileItem(Scope env);
SDocFileItem[0] => item : SDelimiter - SFileItem(env) item;
SDocFileItem[5] => applyDoc(c, item) : SFindDoc c - SFileItem(env) item;

// Root rule. Used to parse an entire file, except the use-statements).
Content SFile(Scope env);
SFile => Content() : (SDocFileItem(env) -> add)* - SDelimiter;

// Root rule for parsing includes.
Array<SrcName> SIncludes();
SIncludes => p : (, "use" #keyword, SPackage p, ";")*;

// Special use-rule in the top loop.
SrcName SReplUse();
SReplUse => p : "use", SPackage p, ";?";

// Root rule for the top loop.
Expr SReplExpr(Block block);
SReplExpr => p : SExpr(block) p;
SReplExpr => p : SStmt(block) p;
SReplExpr => Expr(pos) : "";

// Help.
SReplExpr[10] => helpStmt(block, name) : "help " #keyword, SFnName name;


////////////////////////////////////////////////////////////////////
// Code!
////////////////////////////////////////////////////////////////////

// A single actual parameter (not inlined due to extensibility).
void SActual(Actuals to, Block block);
SActual => to : SExpr(block) -> add;

// Actual parameters
Actuals SActuals(Block block);
SActuals => Actuals() : ;
SActuals => Actuals() : SActual(me, block) - (, ",", SActual(me, block))*;

// Actual parameters with/without parens.
Actuals SFnActuals(Block block);
SFnActuals => Actuals() : ;
SFnActuals => v : "(", SActuals(block) v, ")";

// Block.
Block SBlock(Block parent);
SBlock => ExprBlock(pos, parent) : "{" [, (SBlockItem(me), )* ]+ "}";

// Single item inside a block.
void SBlockItem(ExprBlock parent);
SBlockItem => parent : SStmt(parent) -> add;

// Weak casts, ie. casts that can fail. Note that if (x) is excluded from here, as it is difficult
// to distinguish from the case where 'c' is a boolean by syntax alone. This part will probably contain
// more parts in the future.
WeakCast SWeakCast(Block block);
SWeakCast => weakAsCast(block, expr, type) : SExpr(block) expr, "as" #keyword, SType type;

// All weak casts, including those that are only expressions.
WeakCast SAllWeakCast(Block block);
SAllWeakCast => WeakMaybeCast(expr) : SExpr(block) expr;
SAllWeakCast => r : SWeakCast(block) r;

// If.
IfExpr SIf(Block block);
SIf[0] => createIf(block, expr) :
    "if" #keyword, "(", SExpr(block) expr, ")" - SIfTrue(me) -> trueExpr - (, "else" #keyword - [, SStmt(me) -> falseExpr]?)?;
SIf[0] => IfWeak(block, cast) :
    "if" #keyword, "(", SWeakCast(block) cast, ")" - SIfTrue(me) -> trueExpr - (, "else" #keyword - [, SStmt(me) -> falseExpr]?)?;
SIf[5] => IfWeak(block, cast, name) :
    "if" #keyword, "(", SName name #varName, "=", SAllWeakCast(block) cast, ")" - SIfTrue(me) -> trueExpr - (, "else" #keyword - [, SStmt(me) -> falseExpr]?)?;

// Scoping for if and as expressions.
IfTrue SIfTrue(Block parent); // Really only If and IfWeak.
SIfTrue => IfTrue(pos, parent) : [SDelimiter - SStmt(me) -> set]?;

// Return.
Return SReturn(Block block);
SReturn => Return(pos, block) : "return" #keyword;
SReturn => Return(pos, block, expr) : "return" #keyword, SExpr(block) expr;

// The loop.
Expr SLoop(Block block);
SLoop => Loop(pos, block) : "do[ \n\r\t]" #keyword, SStmt(me) -> doBody - (, "while" #keyword, "(", SExpr(me) -> cond, ")", SStmt(me) -> whileBody)?;
SLoop => Loop(pos, block) : "while" #keyword, "(", SExpr(me) -> cond, ")" [, SStmt(me) -> whileBody]?;

// The for loop. Divided into two to get correct scoping.
SLoop => ExprBlock(pos, block) : "for" #keyword, "(", SExpr(me) -> add, ";", SForInner(me) -> add;

For SForInner(Block block);
SForInner => For(pos, block) : SExpr(me) -> test, ";", SExpr(me) -> update, ")" [, SStmt(me) -> body]?;

// Range-based for loop.
SLoop => RangeFor(pos, block, var, in) : "for" #keyword, "(", SName var #varName, "in" #keyword, SExpr(block) in, ")", SStmt(me) -> body;
SLoop => RangeFor(pos, block, k, v, in) : "for" #keyword, "(", SName k #varName, ",", SName v #varName, "in" #keyword, SExpr(block) in, ")", SStmt(me) -> body;

// Unless block.
Unless SUnless(Block block);
SUnless[0] => Unless(block, cast) :
    "unless" #keyword, "(", SAllWeakCast(block) cast, ")" [, SStmt(me) -> fail ]? (, SStmt(me.successBlock) -> success)*;
SUnless[5] => Unless(block, cast, name) :
    "unless" #keyword, "(", SName name, "=", SAllWeakCast(block) cast, ")" [, SStmt(me) -> fail ]? (, SStmt(me.successBlock) -> success)*;

// Initializer list for arrays.
Array<Expr> SArrayInitList(Block block);
SArrayInitList => Array<Expr>() : ",?";
SArrayInitList => Array<Expr>() : SArrayInitItem(me, block), (",", SArrayInitItem(me, block),)* ",?";

// Single item initialization for arrays.
void SArrayInitItem(Array<Expr> to, Block block);
SArrayInitItem => to : SExpr(block) -> push;

// Constants that can be used with units.
Expr SConst(Block block);
SConst => intConstant(pos, nr) : "-?[0-9]+" nr #constant;
SConst => floatConstant(pos, nr) : "-?[0-9]+\.[0-9]+" nr #constant;
SConst[20] => trueConstant(pos) : "true" #constant;
SConst[20] => falseConstant(pos) : "false" #constant;

////////////////////////////////////////////////////////////////////
// Interpolated strings.
////////////////////////////////////////////////////////////////////

SConst => r : "\"" #string - SIntString(block) r #string - "\"" #string;

Expr SIntString(Block block);
SIntString => strConstant(pos, str) : (SPlainString) str;
SIntString => interpolateStr(block, l, fmt, r) : SIntString(block) l - "${", SIntElem(block) fmt, "}" - (SPlainString) r;

void SPlainString() #string;
SPlainString : ;
SPlainString : "[^\"\\$\n]*" - SPlainString;
SPlainString : "\\." - SPlainString;

InterpolatedItem SIntElem(Block block);
SIntElem => InterpolatedItem(block, expr) : SExpr(block) expr;
SIntElem => InterpolatedItem(block, expr) : SExpr(block) expr, "," - (, SIntFmt(me))+;

void SIntFmt(InterpolatedItem item);
SIntFmt => setWidth(pos, item, nr) : "[0-9]+" nr;
SIntFmt => setRight(pos, item) : "r" #keyword;
SIntFmt => setLeft(pos, item) : "l" #keyword;
SIntFmt => setFill(pos, item, ch) : "f" #keyword - "." ch; // Note: does not support surrogate pairs...
SIntFmt => setHex(pos, item) : "x" #keyword;

////////////////////////////////////////////////////////////////////
// Multiline string literals.
////////////////////////////////////////////////////////////////////

SConst[10] => rawMultilineStrConstant(pos, str) : "str" #keyword, "{[ \t]*[\n\r]+" - [SSkipBlock str]+ - "}";

// Skip a block, assuming matching {} and well-behaved strings.
Str SSkipBlock();
SSkipBlock => cont : ( SSkipContent #string ) cont;

void SSkipContent();
SSkipContent : "[ \n\r\t]*" - SSkipContent - "[ \n\r\t]*" - SSkipContent - "[ \n\r\t]*";
SSkipContent : "[^{}/\"']*";
SSkipContent[10] : "//[^\n\r]*[\n\r]";
SSkipContent : "/" - SSkipContent;
SSkipContent : "{" - [SSkipContent]+ - "}";
SSkipContent : "\"" - SStrContent - "\"";
SSkipContent : "'" - SStrContent - "'";

////////////////////////////////////////////////////////////////////
// Atoms!
////////////////////////////////////////////////////////////////////

// Atoms, for example constants and variables/function calls.
Expr SAtom(Block block);
SAtom => v : SConst(block) v;
SAtom => namedExpr(block, name, params) : SType name #varName, SFnActuals(block) params;
SAtom[10] => namedExpr(block, name, dotExpr, params) : SAtom(block) dotExpr, "\.", SName name #varName, SFnActuals(block) params;
SAtom[20] => spawnExpr(expr) : "spawn" #keyword, SExpr(block) expr;
SAtom[20] => NullExpr(pos) : "null" #keyword;
SAtom => ParenExpr(e) : "(", SExpr(block) e, ")";
SAtom => e : SBlock(block) e;
SAtom => e : SIf(block) e;
SAtom => e : SLoop(block) e;
SAtom => accessExpr(block, lhs, par) : SAtom(block) lhs, "\[", SExpr(block) par, "\]";
SAtom => arrayInit(block, t, list) : SType t, ":", "\[" [, SArrayInitList(block) list, ]$ "\]";
SAtom => ArrayInit(pos, block, list) : "\[" [, SArrayInitList(block) list, ]$ "\]";
SAtom[20] => FnPtr(block, name, params) : "&", SFnName name, SFnTypes params;
SAtom[20] => FnPtr(block, dotExpr, name, params) : "&", SAtom(block) dotExpr, "\.", SName name #varName, SFnTypes params;
SAtom => unit(block, value, unit) : SConst(block) value, SUnit unit #typeName;

// Temporary, to turn a value of type T into Maybe<T>, this should be done automatically in the future.
SAtom => asMaybe(block, expr) : "\?", SAtom(block) expr;

////////////////////////////////////////////////////////////////////
// Units!
////////////////////////////////////////////////////////////////////

// Returns a SrcName of a function which is supposed to convert this unit to an object of some kind.
SrcName SUnit();
SUnit => timeUnit(u) : "h"@ u;
SUnit => timeUnit(u) : "min"@ u;
SUnit => timeUnit(u) : "s"@ u;
SUnit => timeUnit(u) : "ms"@ u;
SUnit => timeUnit(u) : "us"@ u;
SUnit => degUnit(u) : "deg"@ u;
SUnit => degUnit(u) : "rad"@ u;

////////////////////////////////////////////////////////////////////
// Operators!
////////////////////////////////////////////////////////////////////

// Pre- and postfix operators. These come in two variants: one prefix and one postfix version, which
// are differentiated using an asterisk in the function name. Eg. ++* and *++.
SStr SPrePostOp();
SPrePostOp => v : "\+\+"@ v;
SPrePostOp => v : "--"@ v;

// Prefix operators. These have no corresponding postfix variant.
SStr SPreOp();
SPreOp => v : "!"@ v;
SPreOp => v : "-"@ v;

// Operators.
OpInfo SOperator();
SOperator => compareLt(op, 600) : "<"@ op;
SOperator => compareGt(op, 600) : ">"@ op;
SOperator => compareLte(op, 600) : "<="@ op;
SOperator => compareGte(op, 600) : ">="@ op;
SOperator => compareEq(op, 500) : "=="@ op;
SOperator => compareNeq(op, 500) : "!="@ op;
SOperator => IsOperator(op, 500, false) : "is"@ op;
SOperator => IsOperator(op, 500, true) : "!is"@ op;
SOperator => assignOperator(op, 100) : "="@ op;
SOperator => ConcatOperator(op, 300) : "#"@ op;
SOperator => op : SAssignableOp op;
SOperator => CombinedOperator(op, 100) : SAssignableOp op - "=";

// Operator combined with assignment. Eg. +=.
OpInfo SAssignableOp();
SAssignableOp => lOperator(op, 900) : "\*"@ op;
SAssignableOp => lOperator(op, 900) : "/"@ op;
SAssignableOp => lOperator(op, 900) : "%"@ op;
SAssignableOp => lOperator(op, 800) : "\+"@ op;
SAssignableOp => lOperator(op, 800) : "\-"@ op;
SAssignableOp => lOperator(op, 700) : "<<"@ op;
SAssignableOp => lOperator(op, 700) : ">>"@ op;
SAssignableOp => lOperator(op, 490) : "&"@ op;
SAssignableOp => lOperator(op, 480) : "^"@ op;
SAssignableOp => lOperator(op, 470) : "|"@ op;


////////////////////////////////////////////////////////////////////
// Expressions!
////////////////////////////////////////////////////////////////////

Expr SExpr(Block block);
SExpr[20] => e : SAtom(block) e;
SExpr => prePostOperator(block, o, e) : SPreOp o, SAtom(block) e;
SExpr => prefixOperator(block, o, e) : SPrePostOp o, SAtom(block) e;
SExpr => postfixOperator(block, o, e) : SAtom(block) e, SPrePostOp o;
SExpr => mkOperator(block, lhs, op, rhs) : SAtom(block) lhs, SOperator op, SExpr(block) rhs;
// This must be larger than operators, as templates may be seen as the < operator otherwise.
SExpr[10] => Var(block, t, name, actual) : SType t, SName name #varName, SFnActuals(block) actual;
SExpr[10] => Var(block, t, name, init) : SType t, SName name #varName, "=", SExpr(block) init;
SExpr[20] => Var(block, name, init) : "var" #keyword, SName name #varName, "=", SExpr(block) init;


// Statement. A statement is either an expression with its attached ;, or a block without ;.
Expr SStmt(Block block);
SStmt => expr : SExpr(block) expr, ";";
SStmt => Expr(pos) : ";";
SStmt => e : SBlock(block) e;
SStmt[10] => e : SIf(block) e;
SStmt[10] => e : SLoop(block) e;
SStmt[10] => e : SReturn(block) e, ";";
SStmt[20] => e : SUnless(block) e;


////////////////////////////////////////////////////////////////////
// Access modifiers.
////////////////////////////////////////////////////////////////////

// Access modifiers for things inside types. They have a slightly different meaning compared
// to free functions and variables.
Visibility STypeAccess() #keyword;
STypeAccess => typePublic() : "public";
STypeAccess => typeProtected() : "protected";
STypeAccess => typePackage() : "package";
STypeAccess => typePrivate() : "private";

// Access modifiers for things outside of types.
Visibility SFreeAccess() #keyword;
SFreeAccess => freePublic() : "public";
SFreeAccess => freePackage() : "package";
SFreeAccess => freePrivate() : "private";

////////////////////////////////////////////////////////////////////
// Function and class bodies!
////////////////////////////////////////////////////////////////////

// Root rule for parsing function bodies.
FnBody SFunctionBody(BSFunction fn);
SFunctionBody => FnBody(fn) : (SStmt(me) -> add, )*;

// Special statement for calling super constructor.
SuperCall SSuperCall(CtorBody block);
SSuperCall => SuperCall(pos, block, params) : "init" #keyword, SFnActuals(block) params, ";";
SSuperCall => SuperCall(pos, block, params, init) : "init" #keyword, SFnActuals(block) params, "{", (SInitializer(block) init, ";", )* "}";

Initializer SInitializer(Block block);
SInitializer => Initializer(name, value) : SName name #varName, "=", SExpr(block) value;
SInitializer => Initializer(name, params) : SName name #varName, SFnActuals(block) params;

// Root rule for parsing constructor bodies.
CtorBody SCtorBody(BSCtor fn);
SCtorBody => CtorBody(fn) : SCtorStmts(me) -> add, SSuperCall(me) -> add, SCtorStmts(me) -> add;

Array<Expr> SCtorStmts(Block block);
SCtorStmts => v : (SStmt(block) v, )*;

// Constructor parameters. May include a nameless first parameter.
Array<NameParam> SCtorParams();
SCtorParams => Array<NameParam>() : "";
SCtorParams => Array<NameParam>() : SFormal -> push - (, ",", SFormal -> push)*;
SCtorParams => Array<NameParam>() : SFirstFormal -> push - (, ",", SFormal -> push)*;

NameParam SFirstFormal();
SFirstFormal => nameless(type) : SType type;

// Possible contents of a class. Note that all except types are captured and loaded later
// to make sure nested types work as expected.
TObject SClassItem(Class owner);
SClassItem => c : SClass(owner.scope) c;
SClassItem => MemberWrap(item) : SClassWrapItem@ item;

// Class items possible to put access modifiers (and other decorators) in front of.
Named SClassWrapItem(Class owner);
SClassWrapItem[0] => classVar(owner, t, n) :
    SType t, SName n #varName, ";";
SClassWrapItem[0] => classFn(owner, pos, name, result, params, body) :
    SType result, SFnDeclName name #fnName, "(", SFormals params, ")", "{"[, SFunctionBody@ body,]+ "}";
SClassWrapItem[5] => classAssign(owner, pos, name, params, body) :
    "assign" #keyword, SFnDeclName name #fnName, "(", SFormals params, ")", "{"[, SFunctionBody@ body,]+ "}";
SClassWrapItem[5] => classCtor(owner, pos, params, body) :
    "init" #keyword, "(", SCtorParams params, ")", "{"[, SCtorBody@ body,]+ "}";
SClassWrapItem[5] => classCastCtor(owner, pos, params, body) :
    "cast" #keyword, "(", SCtorParams params, ")", "{"[, SCtorBody@ body,]+ "}";


// Contents of a class, including access modifiers.
TObject SClassAccessItem(Class owner);
SClassAccessItem => item : SClassItem(owner) item;
SClassAccessItem => item : [STypeAccess item - ":"]-;
SClassAccessItem => apply(pos, item, access) : STypeAccess access - " ", SClassItem(owner) item;

TObject SDocClassItem(Class owner);
SDocClassItem[0] => item : SDelimiter - SClassAccessItem(owner) item;
SDocClassItem[5] => applyDoc(c, item) : SFindDoc c - SClassAccessItem(owner) item;

// Root rule for parsing classes and values.
ClassBody SClassBody(Class owner);
SClassBody => ClassBody(owner) : (SDocClassItem(owner) -> add)* - SDelimiter;
