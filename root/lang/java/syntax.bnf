// Implementation of the grammar for Java, complete with highlighting annotations.
// Source: https://docs.oracle.com/javase/specs/jls/se7/html/jls-18.html

use core.lang;

optional delimiter = SDelimiter;
required delimiter = RSDelimiter;

void SDelimiter();
SDelimiter : "[ \n\r\t]*" - (SCommentStart #comment - SDelimiter)?;

void RSDelimiter();
RSDelimiter : "[ \n\r\t]+" - (SCommentStart #comment - SDelimiter)?;

void SCommentStart();
SCommentStart : "//[^\n\r]*[\n\r]+";
SCommentStart : "/" - "\*" - [SInComment]@;

// Multiline comments.
void SInComment();
SInComment : "\*+/"; // End of the comment.
SInComment : "/\*+" - SInComment - SInComment; // Start of a nested comment.
SInComment : "[^\*/]*" - SInComment; // Everything except * and / are fine.
SInComment : "\*+[^\*/]" - SInComment;
SInComment : "/+" - SInComment;


// Identifiers.
SStr SIdent();
SIdent => v : "[A-Za-z_$][A-Za-z0-9_$]*" @v;

// Qualified identifier.
SStr SQIdent();
SQIdent : SIdent #typeName - (, "\.", SIdent #typeName)*;

void SQIdentList();
SQIdentList : SQIdent - (, ",", SQIdent)*;


// Start of the grammar.
Content SRoot();
//SRoot : SDelimiter - SPkgName, SImportDecl, STypeDecl - SDelimiter;
SRoot => Content() : SDelimiter - (SPkgName,)? SImportDecl, STypeDecl(me) - SDelimiter;

void SPkgName();
SPkgName : (SAnnotation, )* "package" #keyword, SQIdent #typeName, ";";

void SImportDecl();
SImportDecl[-1] :;
SImportDecl : "import" #keyword ~ ("static" #keyword,)? SQIdent, SImportEnd, ";", SImportDecl;

void SImportEnd();
SImportEnd : ("\.\*")?;

//void STypeDecl();
void STypeDecl(Content content);
//STypeDecl : SModifiers, SClassDecl;
STypeDecl => content : SModifiers, SClassDecl -> add;
STypeDecl : SModifiers, SEnumDecl;
STypeDecl : SModifiers, SInterfaceDecl;
STypeDecl : SModifiers, SAnnotationDecl;

JavaType SClassDecl();
//SClassDecl => JavaType(name, params, implements, extends, body) : "class" #keyword ~ SIdent name #typeName, STypeParams params, (SExtends extends,)? SImplements implement, SClassBody body;
SClassDecl => JavaType(name, params, implement, extends, body) : "class" #keyword ~ SIdent name #typeName, STypeParams @params, (SExtends @extends,)? SImplements @implement, SClassBody(me) @body;

void SEnumDecl();
SEnumDecl : "enum" #keyword, SIdent #typeName, SImplements, SEnumBody;

void SInterfaceDecl();
SInterfaceDecl : "interface" #keyword, SIdent #typeName, STypeParams, SExtendsList, SInterfaceBody;

void SAnnotationDecl();
SAnnotationDecl : "@" #keyword, "interface" #keyword, SIdent #typeName, SAnnotationBody;

void SExtends();
SExtends : "extends" #keyword, SType;
SExtends :;

void SExtendsList();
SExtendsList : "extends" #keyword, STypeList;
SExtendsList :;

void SImplements();
SImplements : "implements" #keyword, STypeList;
SImplements :;


// Types.
Value SType();
SType => type : SBasicType type - (, "\[\]")*;
SType : SRefType;

//TODO: double

Value SBasicType();
SBasicType : "byte" #typeName; //Byte
SBasicType : "short" #typeName; //Byte också?
SBasicType => charType() : "char" #typeName;
SBasicType => intType() : "int" #typeName;
SBasicType => longType() : "long" #typeName;
SBasicType => floatType() : "float" #typeName; //Float
SBasicType => doubleType() : "double" #typeName;
SBasicType => boolType() : "boolean" #typeName;
SBasicType => nullValue() : "void" #typeName;

void SRefType();
// Note: The official documentation does not allow SArrayTokens here. We do, since the official
// Java compiler seems to allow new Foo<Bar[]>();
SRefType : SIdent #typeName, STypeArgs - (, "\.", SIdent #typeName, STypeArgs)*, SArrayTokens;

void STypeList();
STypeList : SRefType - (, ",", SRefType)*;

void STypeActuals();
STypeActuals : ;
STypeActuals : "<", ">";
STypeActuals : "<", STypeList, ">";

void STypeArgs();
STypeArgs :;
STypeArgs : "<", STypeArg - (, ",", STypeArg)*, ">";

void STypeArg();
STypeArg : SRefType;
STypeArg : "\?";
STypeArg : "\?", "extends", SRefType;
STypeArg : "\?", "super", SRefType;

// Type parameters.
void STypeParams();
STypeParams :;
STypeParams : "<", STypeParam - (, ",", STypeParam)*, ">";

void STypeParam();
STypeParam : SIdent, ("extends", SBound)?;

void SBound();
SBound : SRefType - (, "&", SRefType)*;

// Modifiers.
void SModifiers();
SModifiers : (SModifier, )*;

// public, protected, private bör vara Visibility.
// alternativt, skicka in som sträng och resolve:a alla modifiers i implementationen
void SModifier();
SModifier : SAnnotation;
SModifier : "public" #keyword;
SModifier : "protected" #keyword;
SModifier : "private" #keyword;
SModifier : "static" #keyword;
SModifier : "abstract" #keyword;
SModifier : "final" #keyword;
SModifier : "native" #keyword;
SModifier : "synchronized" #keyword;
SModifier : "transient" #keyword;
SModifier : "volatile" #keyword;
SModifier : "strictfp" #keyword;

// Annotations.
void SAnnotation();
SAnnotation : "@" #keyword, SQIdent #keyword - (, SAnnotationParams)?;

void SAnnotationParams();
SAnnotationParams : "(", ")";
SAnnotationParams : "(", SAnnotationElement, ")";

void SAnnotationElement();
SAnnotationElement : SElementValue;
SAnnotationElement : SElementValuePair - (, ",", SElementValuePair)*;

void SElementValuePair();
SElementValuePair : SIdent #varName, "=", SElementValue;

void SElementValue();
SElementValue : SAnnotation;
SElementValue : SExpr1;
SElementValue : "{", SElementArray, (",",)? "}";

void SElementArray();
SElementArray : SElementValue - (, ",", SElementValue)*;

// Expressions and blocks.
Expr SExpr(Block block);
SExpr => e : SExpr1(block) e;
SExpr : SExpr1(block), SAssignOp, SExpr1;

void SAssignOp();
SAssignOp : "=";
SAssignOp : "\+=";
SAssignOp : "-=";
SAssignOp : "*=";
SAssignOp : "/=";
SAssignOp : "&=";
SAssignOp : "|=";
SAssignOp : "%=";
SAssignOp : "<<=";
SAssignOp : ">>=";
SAssignOp : ">>>=";

Expr SExpr1(Block block);
// Note: The original documentation allows an assignment between ? and :, which seems strange.
SExpr1 => e : SExpr2(block) e;
SExpr1 : SExpr2(block), "?", SExpr1, ":", SExpr1;

Expr SExpr2(Block block);
SExpr2 => e : SExpr3(block) e - (, SExpr2Rest)*;

void SExpr2Rest();
// Note: The Java grammar actually disallows 'x instanceof Foo && y'. We allow it here, since
// it seems to be allowed by the Java compiler.
SExpr2Rest : "instanceof" #keyword, SType;
SExpr2Rest : SInfixOp, SExpr3;

void SInfixOp();
SInfixOp : "||";
SInfixOp : "&&";
SInfixOp : "|";
SInfixOp : "^";
SInfixOp : "&";
SInfixOp : "==";
SInfixOp : "!=";
SInfixOp : ">";
SInfixOp : "<";
SInfixOp : "<=";
SInfixOp : ">=";
SInfixOp : "<<";
SInfixOp : ">>";
SInfixOp : ">>>";
SInfixOp : "\+";
SInfixOp : "-";
SInfixOp : "\*";
SInfixOp : "/";
SInfixOp : "%";

Expr SExpr3(Block block);
SExpr3 : SPrefixOp, SExpr3;
SExpr3 => p : SPrimary(block) p, SExpr3Tail;
// This also seems wrong in the documentation, the documentation allows (1)3 as an expression...
SExpr3 : "(", SType, ")", SExpr3;

void SExpr3Tail();
SExpr3Tail : ("\.", SSelector,)* SExpr3Tail2;

void SExpr3Tail2();
SExpr3Tail2 : (SPostfixOp,)*;

void SPrefixOp();
SPrefixOp : "\+\+";
SPrefixOp : "--";
SPrefixOp : "!";
SPrefixOp : "~";
SPrefixOp : "\+";
SPrefixOp : "-";

void SPostfixOp();
SPostfixOp : "\+\+";
SPostfixOp : "--";

Expr SPrimary(Block block);
SPrimary : "(", SExpr, ")";
SPrimary : "[0-9]+[Ll]?" #constant;
SPrimary : "0[Xx][0-9A-Fa-f]+[Ll]?" #constant;
SPrimary : SFloat #constant - ("[fFdD]" #constant)?;
SPrimary : "true" #constant;
SPrimary : "false" #constant;
SPrimary : "null" #constant;
SPrimary => StrLiteral(pos, str) : "\"" #string - SStrContent str #string - "\"" #string;
SPrimary : "'" #string - SCharContent #string - "'" #string;
SPrimary : "this" #keyword - (, SArgs)?;
SPrimary : "super" #keyword - (, SArgs)?;
SPrimary : "super" #keyword, "\.", SIdent #fnName - (, SArgs)?;
SPrimary[-1] => FnCall(pos, block, id, args) : SIdent id, SArgs(block) args;
// SPrimary[-1] : SIdent #varName - (, SIdentSuffix)*;
SPrimary : SBasicType #typeName, ("\[\]",)* "\.", "class" #keyword;
SPrimary : "void" #typeName, "\.", "class" #keyword;
SPrimary : "new[ \t]" #keyword, SCreator;
SPrimary : "<", STypeList, ">", "this" #keyword, SArgs;
SPrimary : "<", STypeList, ">", "super" #keyword, SSelector;
SPrimary : "<", STypeList, ">", SIdent #fnName, SArgs;

void SCreator();
SCreator : "<", STypeList, ">", SCreatedName, SCreatorRest;
SCreator : SCreatedName, SCreatorRest;
SCreator : SCreatedName, SArrayRest;

void SCreatedName();
SCreatedName : SIdent #typeName, STypeArgs - (, "\.", SIdent #typeName, STypeActuals)*;

void SCreatorRest();
SCreatorRest : SArgs - (, SClassBody)?;

void SArrayRest();
// TODO: Figure out how this should be implemented...
SArrayRest : "\[", SExpr, "\]" - (, "\[", SExpr, "\]")*, SArrayTokens;
SArrayRest : ("\[\]",)+ SArrayInit;

void SArrayTokens();
SArrayTokens : ;
SArrayTokens : "\[\]" - (, "\[\]")*;

void SFloat();
SFloat : SFloatBase - (SFloatExp)?;
SFloat : "[0-9]+" - SFloatExp;

void SFloatBase();
SFloatBase : "[0-9]+\.[0-9]*";
SFloatBase : "\.[0-9]+";

void SFloatExp();
SFloatExp : "e[+\-]?[0-9]+";

SStr SStrContent();
SStrContent => str : "[^\"\\\n]*" @str;
SStrContent : SStrContent - "\\." - SStrContent;

void SCharContent();
SCharContent : "[^\\']";
SCharContent : "\\.";

void SIdentSuffix();
SIdentSuffix : ;
SIdentSuffix[-1] : "\.", SIdent #varName;
SIdentSuffix : ("\[\]", )* "\.", "class" #keyword;
SIdentSuffix : "\[", SExpr, "\]"; // Strange to have an expression in this context...
SIdentSuffix : SArgs(block);
SIdentSuffix : "\.", "this" #keyword;
SIdentSuffix : "\.", "super" #keyword, SArgs;
SIdentSuffix : "\.", "new" #keyword, STypeActuals, SIdent #typeName, STypeActuals, SArgs - (,SClassBody)?;
SIdentSuffix : "\.", STypeActuals, "super" #keyword, SSelector;
SIdentSuffix : "\.", STypeActuals, SIdent #fnName, SArgs;

Array<Expr> SArgs(Block block);
SArgs : "(", ")";
SArgs => Array<Expr>() : "(", SExpr(block) -> push, (",", SExpr(block) -> push, )*, ")";

void SSelector();
SSelector : SIdent #fnName - (, SArgs)?;
SSelector : "this" #keyword;
SSelector[10] : "super" #keyword - (, SArgs)?;
SSelector[10] : "super" #keyword, "\.", SSelector;
SSelector : "new" #keyword, STypeActuals, SIdent #typeName, STypeActuals, SArgs - (,SClassBody)?;
SSelector : "<", STypeList, ">", SGenericSuffix;
SSelector : "\[", SExpr, "\]";

void SGenericSuffix();
SGenericSuffix : "super" #keyword, SSelector;
SGenericSuffix : SIdent #fnName, SArgs;

Stmt SStmt(Block block);
SStmt : ";";
SStmt : SBlock;
SStmt : SIdent, ":", SStmt;
SStmt => e : SExpr(block) e, ";";
SStmt[10] : "assert[ \t]" #keyword, SExpr, (":", SExpr,)? ";";
SStmt[10] : "if" #keyword, "(", SExpr, ")" [, SStmt]? - (, SStmtElse)?;
SStmt[10] : "while" #keyword, "(", SExpr, ")" [, SStmt]?;
SStmt[10] : "do[ \t]" #keyword [, SStmt, ]? "while" #keyword, "(", SExpr, ")", ";";
SStmt[10] : "for" #keyword, "(", SForControl, ")" [, SStmt]?;
SStmt[10] : "break" #keyword - (, SIdent)?;
SStmt[10] : "continue" #keyword - (, SIdent)?;
SStmt[10] : "return[ \t]" #keyword, SExpr;
SStmt[10] : "throw[ \t]" #keyword, SExpr;
SStmt[10] : "synchronized", "(", SExpr, ")", SBlock;
SStmt[10] : "try" #keyword, SBlock, STryTail;
SStmt[10] : "try" #keyword, "(", SResourceSpec, (";",)? ")", SBlock, STryTail;
SStmt[10] : "switch" #keyword, "(", SExpr, ")", "{", (SSwitchStmt,)* "}";

void SSwitchStmt();
SSwitchStmt : SStmt;
SSwitchStmt : "case[ \t]" #keyword, SExpr, ":";
SSwitchStmt : "default" #keyword, ":";

void SStmtElse();
SStmtElse : "else" #keyword [, SStmt]?;

void STryTail();
STryTail : (SCatchClause, )* "finally" #keyword, SBlock;
STryTail : (SCatchClause, )+;

void SCatchClause();
SCatchClause : "catch" #keyword, "(", SVarModifier, SQIdent, ("|", SQIdent,)* SIdent #varName, ")", SBlock;

void SResourceSpec();
SResourceSpec : SVarModifier, SRefType, SIdent #varName, ("\[\]",)* "=", SExpr;
SResourceSpec : SResourceSpec, ";", SResourceSpec;

void SForControl();
SForControl : SForStmt, ";", SForStmt, ";", SForStmt;
SForControl : SVarModifier, SType, SIdent #varName, ("\[\]",)* SForControlRest;

void SForControlRest();
SForControlRest : ":", SExpr;
SForControlRest : "=", SVarInit, (",", SIdent #varName, SVarSuffix,)* ";", SForStmt, ";", SForStmt;

void SForStmt();
SForStmt : ;
SForStmt : SExpr, (",", SExpr)*;

Block SBlockStmt(Block block);
SBlockStmt[10] => block : SStmt(block) -> add;
SBlockStmt : STypeDecl;
SBlockStmt : SVarModifier, SType, SIdent #varName, SVarSuffix, (",", SIdent #varName, SVarSuffix,)* ";";

Block SBlock(Block parent);
SBlock => Block(pos, parent) : "{" [, (SBlockStmt(me) -> add,)* ]+ "}";

// Class body.
void SClassBody(JavaType type); //JavaType type som parameter, ser till att lägga till alla funktioner sen
SClassBody : "{" [, (SClassEntry(type),)*]+ "}";

void SClassEntry(JavaType type);
SClassEntry => type : ";";
SClassEntry => type : SModifiers, SMemberDecl -> add;
SClassEntry => type : ("static" #keyword,)? SBlock;

JavaFnDecl SMemberDecl();
SMemberDecl : STypeDecl;
SMemberDecl : SType, SIdent #varName, SVarSuffix, (",", SIdent #varName, SVarSuffix,)* ";";
SMemberDecl => JavaFnDecl(result, name, formals, qlist, end): SType result, SIdent name #fnName, SFormals @formals, ("throws" #keyword, SQIdentList @qlist,)? SMethodEnd @end;
SMemberDecl : SIdent #typeName, SFormals, ("throws" #keyword, SQIdentList,)? SBlock;
// generics?:
//SMemberDecl : STypeParams, SType, SIdent #fnName, SFormals, ("throws" #keyword, SQIdentList,)? SMethodEnd;
//SMemberDecl : STypeParams, SIdent #typeName, SFormals, ("throws" #keyword, SQIdentList,)? SBlock;

Block SMethodEnd(Block parent);
SMethodEnd : ";";
SMethodEnd => block : SBlock(parent) block;

void SFormals();
SFormals : "(", (SFormalList)?, ")";

void SFormalList();
SFormalList : SVarModifier, SType, SIdent #varName, (",", SFormalList)?;
SFormalList : SVarModifier, SType, SIdent #varName, "\[\]", (",", SFormalList)?;
SFormalList : SVarModifier, SType, "\.\.\.", SIdent #varName;

void SVarModifier();
SVarModifier : ;
SVarModifier : "final" #keyword, SVarModifier;
SVarModifier : SAnnotation, SVarModifier;

void SVarSuffix();
SVarSuffix : ("\[\]",)*;
SVarSuffix : ("\[\]",)* "=", SVarInit;

void SVarInit();
SVarInit : SExpr;
SVarInit : SArrayInit;

void SArrayInit();
SArrayInit : "{", "}";
SArrayInit : "{", ",", "}";
SArrayInit : "{", SVarInit, (",", SVarInit, )* "}";
SArrayInit : "{", SVarInit, (",", SVarInit, )* ",", "}";

// Enum body.
void SEnumBody();
SEnumBody : "{" [, SEnumConsts, SEnumDecls, ]+ "}";

void SEnumConsts();
SEnumConsts : ;
SEnumConsts : SEnumConst - (, ",")?;
SEnumConsts : SEnumConst, ",", SEnumConsts;

void SEnumConst();
SEnumConst : (SAnnotation,)* SIdent #varName, SEnumConstTail;

void SEnumConstTail();
SEnumConstTail : (SArgs,)? SClassBody;
SEnumConstTail : SArgs;
SEnumConstTail : ;

void SEnumDecls();
SEnumDecls : ;
SEnumDecls : ";" - (, SClassEntry)*;

// Interface body.
void SInterfaceBody();
SInterfaceBody : "{" [, (SInterfaceEntry,)* ]+ "}";

void SInterfaceEntry();
SInterfaceEntry : ";";
SInterfaceEntry : SModifiers, SMemberDecl;

// Annotation body.
void SAnnotationBody();
SAnnotationBody : "{" [, (SModifiers, SAnnotationEntry,)* ]+ "}";

void SAnnotationEntry();
SAnnotationEntry : SClassDecl;
SAnnotationEntry : SEnumDecl;
SAnnotationEntry : SInterfaceDecl;
SAnnotationEntry : SAnnotationDecl;
SAnnotationEntry : SType, SIdent #varName, "(", ")", "\[\]", ("default" #keyword, SElementValue,)? ";";
SAnnotationEntry : SType, SIdent #varName, "(", ")", ("default" #keyword, SElementValue,)? ";";
SAnnotationEntry : SType, SIdent #varName, SVarSuffix, (",", SIdent #varName, SVarSuffix,)* ";";
