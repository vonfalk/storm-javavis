use core:lang;
use core:asm;
use lang:bs:macro;

class Expr extends Stmt {
    init(SrcPos pos) {
        init(pos) {}
    }

    Bool code(CodeGen gen) : abstract;

    void code(CodeGen gen, CodeResult res) : abstract;

    Value result() : abstract;
}

class StrLiteral extends Expr {
    init(SrcPos pos, SStr val) {
        init(pos) {
            val = val.v.toS.unescape();
        }
    }

    private Str val;

    Value result() : override {
        Value(named{Str});
    }

    Bool code(CodeGen gen) : override {
        gen.l << mov(ptrA, objPtr(val));
        true;
    }

    void code(CodeGen gen, CodeResult res) : override { throw SyntaxError(pos, "StrLiteral:code(CodeGen, CodeRes) is not yet implemented."); }
}

class IntLiteral extends Expr {
    init(SrcPos pos, Long val) {
        init(pos) { val = val; }
    }

    init(SrcPos pos, Str str) {
        init(pos) { val = str.toLong(); }
    }

    private Long val;

    Value result() : override {
        Value(named{Int}, true);
    }

    Bool code(CodeGen gen) : override {
        gen.l << mov(ptrA, longConst(val));
        true;
    }

    void code(CodeGen gen, CodeResult res) : override { throw SyntaxError(pos, "IntLiteral:code(CodeGen, CodeRes) is not yet implemented."); }
}

class BoolLiteral extends Expr {
    init(SrcPos pos, Bool val) {
        init(pos) { val = val; }
    }

    private Bool val;

    Value result() : override {
        Value(named{Bool});
    }

    void code(CodeGen gen, CodeResult res) : override {
        if (!res.needed())
            return;
        
        Byte val = if (this.val) { 1b; } else {0b; };
        var to = res.location(gen);
        gen.l << mov(to, byteConst(val));

        res.created(gen);
    }

    Bool code(CodeGen gen) : override {
        Byte val = if (this.val) { 1b; } else { 0b; };
        gen.l << mov(byteRel(ptrA), byteConst(val));
        true;
    }
}

class FnCall extends Expr {
    private Function fn;
    private Expr[] args;

    init(SrcPos pos, Block block, SStr id, Expr[] args) {
        init(pos) {
            fn = findFn(pos, block, id, args);
            args = args;
        }
    }

    Value result() : override {
        fn.result;
    }

    void code(CodeGen gen, CodeResult res) : override { throw SyntaxError(pos, "FnCall:code(CodeGen, CodeRes) is not yet implemented."); }

    Bool code(CodeGen gen) : override {
        Operand[] ops;
        for (e in args) {
            e.code(gen);
            var v = gen.l.createVar(gen.block, e.result.size);
            ops << v;
            gen.l << mov(v, asSize(ptrA, v.size));
        }
        if (fn.result == Value()) {
            fn.autoCall(gen, ops, CodeResult());
        }
        else {
            CodeResult codeRes(fn.result, gen.block);
            fn.autoCall(gen, ops, codeRes);
            gen.l << mov(asSize(ptrA, fn.result.size), codeRes.location(gen));
        }
        true;
    }

    private Function findFn(SrcPos pos, Block block, SStr id, Expr[] args):static {
        Value[] types;
        for (e in args) {
            types << e.result();
        }
        SimpleName sName(id.v, types);
        
        if (fn = block.scope.find(sName) as Function) {
            return fn;
        }

        throw SyntaxError(pos, "Could not find function ${sName}.");
    }
}